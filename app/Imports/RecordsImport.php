<?php

namespace App\Imports;

use App\Models\Container;
use App\Models\Dolly;
use App\Models\RecordPhysical;
use App\Models\RecordLevel;
use App\Models\RecordStatus;
use App\Models\RecordSupport;
use App\Models\Activity;
use App\Models\Author;
use App\Models\ThesaurusConcept;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Maatwebsite\Excel\Concerns\ToModel;
use Maatwebsite\Excel\Concerns\WithBatchInserts;
use Maatwebsite\Excel\Concerns\WithChunkReading;

class RecordsImport implements ToModel, WithBatchInserts, WithChunkReading
{
    protected Dolly $dolly;
    protected array $mapping;
    protected bool $hasHeaders;
    protected bool $updateExisting;
    protected bool $autoGenerateCodes;
    protected int $currentRow = 0;
    protected int $importedCount = 0;
    protected int $skippedCount = 0;
    protected int $autoGeneratedCodes = 0;
    protected array $skippedRows = [];
    protected array $errors = [];

    public function __construct(Dolly $dolly, array $mapping = [], bool $hasHeaders = true, bool $updateExisting = false, bool $autoGenerateCodes = true)
    {
        $this->dolly = $dolly;
        $this->mapping = $mapping;
        $this->hasHeaders = $hasHeaders;
        $this->updateExisting = $updateExisting;
        $this->autoGenerateCodes = $autoGenerateCodes;
    }

    public function model(array $row)
    {
        $this->currentRow++;

        // Ignorer la première ligne si elle contient les en-têtes
        if ($this->hasHeaders && $this->currentRow === 1) {
            return null;
        }

        try {
            // Nettoyer toutes les valeurs du row pour éviter les erreurs Array to string
            $cleanRow = [];
            foreach ($row as $key => $value) {
                if (is_array($value)) {
                    $cleanRow[$key] = implode(', ', array_filter($value, function($item) {
                        return $item !== null && $item !== '';
                    }));
                } else {
                    $cleanRow[$key] = (string) $value;
                }
            }

            $mappedData = $this->mapRowData($cleanRow);

            // Ignorer les lignes complètement vides
            if (empty($mappedData)) {
                $this->skippedRows[] = [
                    'row' => $this->currentRow,
                    'data' => $cleanRow,
                    'reason' => 'Ligne vide - aucune donnée mappée'
                ];
                $this->skippedCount++;
                Log::warning("Ligne {$this->currentRow} ignorée: aucune donnée mappée", [
                    'row_data' => $cleanRow
                ]);
                return null;
            }

            if (!$this->validateRequiredFields($mappedData)) {
                $missingFields = $this->getMissingFields($mappedData);
                $this->skippedRows[] = [
                    'row' => $this->currentRow,
                    'data' => $mappedData,
                    'missing_fields' => $missingFields
                ];
                $this->skippedCount++;
                Log::warning("Ligne {$this->currentRow} ignorée: champs requis manquants", [
                    'missing_fields' => $missingFields,
                    'mapped_data' => $mappedData
                ]);
                return null;
            }

            $record = $this->createOrUpdateRecord($mappedData);

            if ($record) {
                $this->dolly->records()->attach($record->id);
                $this->processAuthors($record, $mappedData);
                $this->processTerms($record, $mappedData);
                $this->importedCount++;
            }

            return $record;
        } catch (\InvalidArgumentException $e) {
            $this->errors[] = [
                'row' => $this->currentRow,
                'error' => 'Erreur de validation: ' . $e->getMessage(),
                'data' => $row
            ];
            Log::error("Erreur de validation ligne {$this->currentRow}: " . $e->getMessage(), [
                'row_data' => $row,
                'mapped_data' => $mappedData ?? []
            ]);
            return null;
        } catch (\Exception $e) {
            $this->errors[] = [
                'row' => $this->currentRow,
                'error' => $e->getMessage(),
                'data' => $row
            ];
            Log::error("Erreur ligne {$this->currentRow}: " . $e->getMessage(), [
                'row_data' => $row,
                'mapped_data' => $mappedData ?? [],
                'trace' => $e->getTraceAsString()
            ]);
            return null;
        }
    }

    protected function mapRowData(array $row): array
    {
        // Si aucun mapping spécifié, tenter un mapping par index identique
        if (empty($this->mapping)) {
            // Essayer de mapper automatiquement les colonnes communes
            $autoMapping = [
                'code' => 0,
                'name' => 1,
                'level' => 2,
                'status' => 3,
                'support' => 4,
                'activity' => 5,
                'content' => 6,
                'start_date' => 7,
                'end_date' => 8,
                'exact_date' => 9,
                'authors' => 10,
                'terms' => 11,
            ];
            
            $mappedData = [];
            foreach ($autoMapping as $field => $index) {
                if (isset($row[$index])) {
                    $value = $this->sanitizeValue($row[$index]);
                    if ($value !== '' && $value !== null) {
                        $mappedData[$field] = $value;
                    }
                }
            }
            return $mappedData;
        }

        $mappedData = [];
        foreach ($this->mapping as $field => $config) {
            $columnIndex = $config['column_index'] ?? null;
            if ($columnIndex !== null && isset($row[$columnIndex])) {
                $value = $this->sanitizeValue($row[$columnIndex]);
                if ($value !== '' && $value !== null) {
                    $mappedData[$field] = $value;
                }
            }
        }
        
        // Corrections temporaires pour un mapping problématique détecté
        if (isset($mappedData['level']) && $mappedData['level'] === 'COMMISSION' && isset($row[2])) {
            $mappedData['level'] = $this->sanitizeValue($row[2]); // Utiliser la colonne 2 pour le niveau
        }
        
        // Corriger le mapping du support s'il contient une description longue
        if (isset($mappedData['support']) && strlen($mappedData['support']) > 50) {
            $mappedData['support'] = 'Papier'; // Valeur par défaut
        }
        
        // Corriger les autres champs trop longs
        foreach (['name', 'content', 'width_description'] as $field) {
            if (isset($mappedData[$field])) {
                $maxLength = ($field === 'name') ? 255 : 1000;
                if (strlen($mappedData[$field]) > $maxLength) {
                    $mappedData[$field] = substr($mappedData[$field], 0, $maxLength - 3) . '...';
                }
            }
        }
        
        return $mappedData;
    }

    protected function sanitizeValue($value)
    {
        // Si c'est un tableau, le convertir en chaîne
        if (is_array($value)) {
            $value = implode(', ', array_filter($value, function($item) {
                return $item !== null && $item !== '';
            }));
        }
        
        // Si c'est un objet, essayer de le convertir en chaîne
        if (is_object($value)) {
            if (method_exists($value, '__toString')) {
                $value = (string) $value;
            } else {
                $value = json_encode($value);
            }
        }
        
        // Si c'est une chaîne, la nettoyer
        if (is_string($value)) {
            $value = trim($value);
        }
        
        // Si c'est un nombre, le convertir en chaîne
        if (is_numeric($value)) {
            $value = (string) $value;
        }
        
        // Si c'est null ou une chaîne vide, retourner null
        if ($value === null || $value === '') {
            return null;
        }
        
        return $value;
    }

    protected function ensureString($value): ?string
    {
        if ($value === null) {
            return null;
        }
        
        // Si c'est déjà une chaîne, la retourner
        if (is_string($value)) {
            return trim($value);
        }
        
        // Si c'est un tableau, le convertir en chaîne
        if (is_array($value)) {
            return implode(', ', array_filter($value, function($item) {
                return $item !== null && $item !== '';
            }));
        }
        
        // Si c'est un objet, essayer de le convertir en chaîne
        if (is_object($value)) {
            if (method_exists($value, '__toString')) {
                return (string) $value;
            } else {
                return json_encode($value);
            }
        }
        
        // Si c'est un nombre, le convertir en chaîne
        if (is_numeric($value)) {
            return (string) $value;
        }
        
        // Pour tout autre type, essayer de le convertir en chaîne
        return (string) $value;
    }

    protected function ensureNumeric($value)
    {
        if ($value === null || $value === '') {
            return null;
        }
        
        // Si c'est déjà un nombre
        if (is_numeric($value)) {
            return $value;
        }
        
        // Si c'est une chaîne, essayer de la convertir en nombre
        if (is_string($value)) {
            $value = trim($value);
            if (is_numeric($value)) {
                return $value;
            }
        }
        
        // Si c'est un tableau, prendre le premier élément numérique
        if (is_array($value)) {
            foreach ($value as $item) {
                if (is_numeric($item)) {
                    return $item;
                }
            }
        }
        
        // Si c'est un objet, essayer de le convertir
        if (is_object($value)) {
            if (method_exists($value, '__toString')) {
                $strValue = (string) $value;
                if (is_numeric($strValue)) {
                    return $strValue;
                }
            }
        }
        
        return null;
    }

    protected function validateRequiredFields(array $data): bool
    {
        $requiredFields = ['name', 'level', 'status', 'support', 'activity'];
        foreach ($requiredFields as $field) {
            if (empty($data[$field])) {
                return false;
            }
        }
        return true;
    }

    protected function getMissingFields(array $data): array
    {
        $requiredFields = ['name', 'level', 'status', 'support', 'activity'];
        $missing = [];
        foreach ($requiredFields as $field) {
            if (empty($data[$field])) {
                $missing[] = $field;
            }
        }
        return $missing;
    }

    protected function generateCode(array $data): string
    {
        // Si un code existe déjà, l'utiliser
        if (!empty($data['code'])) {
            return $this->ensureString($data['code']);
        }

        // Si la génération automatique est désactivée, retourner une erreur
        if (!$this->autoGenerateCodes) {
            throw new \InvalidArgumentException('Le code est requis et la génération automatique est désactivée');
        }

        // Incrémenter le compteur de codes générés automatiquement
        $this->autoGeneratedCodes++;

        // Générer un code basé sur le nom et le niveau
        $name = $this->ensureString($data['name'] ?? '');
        $level = $this->ensureString($data['level'] ?? '');
        
        if (empty($name)) {
            return 'REC_' . strtoupper(substr(md5(uniqid()), 0, 8));
        }

        // Créer un code basé sur le niveau et le nom (max 10 caractères)
        $levelPrefix = empty($level) ? 'R' : strtoupper(substr($level, 0, 1));
        $nameSlug = empty($name) ? 'rec' : $this->createSlug($name);
        
        // Limiter la longueur pour respecter la limite de 10 caractères
        $namePart = substr($nameSlug, 0, 3); // 1 (prefix) + 1 (_) + 3 (name) + 1 (_) + 3 (suffix) = 9 chars
        if (empty($namePart)) {
            $namePart = 'rec';
        }
        
        // Ajouter un suffixe unique basé sur ligne courante
        $suffix = sprintf('%03d', $this->currentRow % 1000); // 3 digits max
        
        return $levelPrefix . '_' . $namePart . '_' . $suffix;
    }

    protected function createSlug(string $string): string
    {
        if (empty($string)) {
            return 'record';
        }
        
        // Convertir en minuscules
        $string = strtolower(trim($string));
        
        // Remplacer les caractères spéciaux par des tirets
        $string = preg_replace('/[^a-z0-9\s-]/', '', $string);
        
        // Remplacer les espaces par des tirets
        $string = preg_replace('/[\s-]+/', '-', $string);
        
        // Supprimer les tirets en début et fin
        $string = trim($string, '-');
        
        // Si le résultat est vide, retourner une valeur par défaut
        return empty($string) ? 'record' : $string;
    }

    protected function createOrUpdateRecord(array $data): ?Record
    {
        // Générer le code automatiquement si nécessaire
        $code = $this->generateCode($data);
        
        $recordData = [
            'code' => $code,
            'name' => $this->ensureString($data['name']),
            'date_format' => $this->ensureString($data['date_format'] ?? 'Y'),
            'date_start' => $this->formatDate($data['start_date'] ?? null),
            'date_end' => $this->formatDate($data['end_date'] ?? null),
            'date_exact' => $this->formatDate($data['exact_date'] ?? null),
            'level_id' => $this->getOrCreateLevel($this->ensureString($data['level'] ?? 'Item'))->id,
            'width' => $this->ensureNumeric($data['width'] ?? null),
            'width_description' => $this->ensureString($data['width_description'] ?? null),
            'biographical_history' => $this->ensureString($data['biographical_history'] ?? null),
            'archival_history' => $this->ensureString($data['archival_history'] ?? null),
            'acquisition_source' => $this->ensureString($data['acquisition_source'] ?? null),
            'content' => $this->ensureString($data['content'] ?? null),
            'appraisal' => $this->ensureString($data['appraisal'] ?? null),
            'accrual' => $this->ensureString($data['accrual'] ?? null),
            'arrangement' => $this->ensureString($data['arrangement'] ?? null),
            'access_conditions' => $this->ensureString($data['access_conditions'] ?? null),
            'reproduction_conditions' => $this->ensureString($data['reproduction_conditions'] ?? null),
            'language_material' => $this->ensureString($data['language_material'] ?? null),
            'characteristic' => $this->ensureString($data['characteristic'] ?? null),
            'finding_aids' => $this->ensureString($data['finding_aids'] ?? null),
            'location_original' => $this->ensureString($data['location_original'] ?? null),
            'location_copy' => $this->ensureString($data['location_copy'] ?? null),
            'related_unit' => $this->ensureString($data['related_unit'] ?? null),
            'publication_note' => $this->ensureString($data['publication_note'] ?? null),
            'note' => $this->ensureString($data['note'] ?? null),
            'archivist_note' => $this->ensureString($data['archivist_note'] ?? null),
            'rule_convention' => $this->ensureString($data['rule_convention'] ?? null),
            'status_id' => $this->getOrCreateStatus($this->ensureString($data['status'] ?? 'Actif'))->id,
            'support_id' => $this->getOrCreateSupport($this->ensureString($data['support'] ?? 'Papier'))->id,
            'activity_id' => $this->getOrCreateActivity($this->ensureString($data['activity'] ?? 'Administration'))->id,
            'user_id' => Auth::id() ?? 1,
        ];

        if ($this->updateExisting && !empty($data['code'])) {
            $existing = RecordPhysical::where('code', $code)->first();
            if ($existing) {
                $existing->update($recordData);
                return $existing;
            }
        }

        return RecordPhysical::create($recordData);
    }

    protected function processAuthors(RecordPhysical $record, array $data): void
    {
        $authorsValue = $this->ensureString($data['authors'] ?? null);
        if (empty($authorsValue)) {
            return;
        }
        
        $authors = array_map('trim', explode(',', $authorsValue));
        $ids = [];
        foreach ($authors as $name) {
            if ($name === '') { continue; }
            $author = Author::firstOrCreate(['name' => $name]);
            $ids[] = $author->id;
        }
        if (!empty($ids)) {
            $record->authors()->sync($ids);
        }
    }

    protected function processTerms(RecordPhysical $record, array $data): void
    {
        $termsValue = $this->ensureString($data['terms'] ?? null);
        if (empty($termsValue)) {
            return;
        }
        
        $terms = array_map('trim', explode(',', $termsValue));
        $attach = [];
        foreach ($terms as $termName) {
            if ($termName === '') { continue; }
            $concept = ThesaurusConcept::whereHas('labels', function ($q) use ($termName) {
                $q->where('literal_form', 'LIKE', '%' . $termName . '%');
            })->first();
            if ($concept) {
                $attach[$concept->id] = [
                    'weight' => 1.0,
                    'context' => 'import',
                    'extraction_note' => 'Importé depuis fichier',
                ];
            }
        }
        if (!empty($attach)) {
            $record->thesaurusConcepts()->sync($attach);
        }
    }

    protected function formatDate($date): ?string
    {
        if (empty($date)) {
            return null;
        }
        
        // Convertir en chaîne si nécessaire
        $dateString = $this->ensureString($date);
        if (empty($dateString)) {
            return null;
        }
        
        $formats = ['Y-m-d', 'd/m/Y', 'm/d/Y', 'Y/m/d', 'd-m-Y', 'Y', 'Y-m'];
        foreach ($formats as $format) {
            $dt = \DateTime::createFromFormat($format, $dateString);
            if ($dt && $dt->format($format) === $dateString) {
                return $dt->format('Y-m-d');
            }
        }
        
        // Si aucun format ne correspond, essayer de parser avec strtotime
        $timestamp = strtotime($dateString);
        if ($timestamp !== false) {
            return date('Y-m-d', $timestamp);
        }
        
        return null;
    }

    protected function getOrCreateLevel($name): RecordLevel
    {
        $nameString = $this->ensureString($name);
        if (empty($nameString)) {
            throw new \InvalidArgumentException('Le nom du niveau ne peut pas être vide');
        }
        // Limiter à 50 caractères (limite réelle de la DB)
        if (strlen($nameString) > 50) {
            $nameString = substr($nameString, 0, 47) . '...';
        }
        return RecordLevel::firstOrCreate(['name' => $nameString], ['name' => $nameString]);
    }

    protected function getOrCreateStatus($name): RecordStatus
    {
        $nameString = $this->ensureString($name);
        if (empty($nameString)) {
            throw new \InvalidArgumentException('Le nom du statut ne peut pas être vide');
        }
        // Limiter à 50 caractères (limite réelle de la DB)
        if (strlen($nameString) > 50) {
            $nameString = substr($nameString, 0, 47) . '...';
        }
        return RecordStatus::firstOrCreate(['name' => $nameString], ['name' => $nameString]);
    }

    protected function getOrCreateSupport($name): RecordSupport
    {
        $nameString = $this->ensureString($name);
        if (empty($nameString)) {
            throw new \InvalidArgumentException('Le nom du support ne peut pas être vide');
        }
        // Limiter à 50 caractères (limite réelle de la DB)
        if (strlen($nameString) > 50) {
            $nameString = substr($nameString, 0, 47) . '...';
        }
        return RecordSupport::firstOrCreate(['name' => $nameString], ['name' => $nameString]);
    }

    protected function getOrCreateActivity($name): Activity
    {
        $nameString = $this->ensureString($name);
        if (empty($nameString)) {
            throw new \InvalidArgumentException('Le nom de l\'activité ne peut pas être vide');
        }
        
        // Limiter à 50 caractères (limite réelle de la DB)
        if (strlen($nameString) > 50) {
            $nameString = substr($nameString, 0, 47) . '...';
        }
        
        // Vérifier d'abord si l'activité existe déjà par nom
        $existing = Activity::where('name', $nameString)->first();
        if ($existing) {
            return $existing;
        }
        
        // Générer un code unique
        $baseCode = strtoupper(substr(preg_replace('/[^A-Za-z0-9]/', '', $nameString), 0, 8));
        $code = $baseCode;
        $counter = 1;
        
        // S'assurer que le code est unique
        while (Activity::where('code', $code)->exists()) {
            $code = $baseCode . sprintf('%02d', $counter);
            $counter++;
            if ($counter > 99) {
                $code = $baseCode . uniqid();
                break;
            }
        }
        
        return Activity::create([
            'name' => $nameString,
            'code' => $code
        ]);
    }

    public function batchSize(): int
    {
        return 1000;
    }

    public function chunkSize(): int
    {
        return 1000;
    }

    public function getImportedCount(): int
    {
        return $this->importedCount;
    }

    public function getSkippedCount(): int
    {
        return $this->skippedCount;
    }

    public function getSkippedRows(): array
    {
        return $this->skippedRows;
    }

    public function getErrors(): array
    {
        return $this->errors;
    }

    public function getAutoGeneratedCodesCount(): int
    {
        return $this->autoGeneratedCodes;
    }

    public function getImportSummary(): array
    {
        return [
            'imported' => $this->importedCount,
            'skipped' => $this->skippedCount,
            'auto_generated_codes' => $this->autoGeneratedCodes,
            'errors' => count($this->errors),
            'total_rows' => $this->currentRow - ($this->hasHeaders ? 1 : 0),
            'skipped_rows' => $this->skippedRows,
            'errors' => $this->errors
        ];
    }
}
